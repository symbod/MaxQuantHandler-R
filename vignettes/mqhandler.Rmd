---
title: "mqhandleR - R Package for the python package mqhandler"
author: Klaudia Adamowicz

output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---



## Introduction {-}

## Installation {-}

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", eval = FALSE
)
```

```{r loading, include=TRUE, warning=FALSE, message=FALSE}
  # Install mqhandleR from github and build vignettes
  if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
  if(!require("mqhandleR",character.only = TRUE)) devtools::install_github("symbod/MaxQuantHandler-R", build_vignettes = TRUE, dependencies = TRUE)
  # Load and attach mqhandleR 
  library("mqhandleR")
```

## Filter Protein IDs

For a protein assignment using MaxQuant, Fasta files are required. Since MaxQuant can also be used to run several data collectively, it can also happen that results are provided with protein IDs of several organisms. 

This method makes it possible to check the protein IDs for their organism by directly accessing the Uniprot database, and to remove incorrectly assigned IDs.

### Setup
```{r}
# mandatory
data = data.table::fread("../../MaxQuantHandler/in/Li2021_proteins_NaOmit_SL_irs.txt")
#data = data.table::fread("<file>")
protein_column = "Protein IDs" # Name of column with protein IDs

# optional 
organism = "human" # Specify organism the ids should match to
res_column = "Filtered IDs" # Name of column of filtered protein IDs. If NULL, the protein_column will be overridden
keep_empty = FALSE # Bool to indicate if empty filtered protein IDs cells should be kept or deleted
reviewed = TRUE # Bool to indicate if newly retrieved protein IDs should be reduced to reviewed ones
decoy = FALSE # Bool to indicate if protein ids from decoy fasta (REV__, CON__) should be kept
```

### Run 
```{r}
filtered_data <- filter_protein_ids(data = data, protein_column = protein_column, organism = organism,
                                    res_column = res_column, keep_empty = keep_empty, 
                                    reviewed = reviewed, decoy = decoy)
```
### Log Information
One might be interested to know how many IDs were filtered out, in total and per row. Therefore, with this call, you can generate 2 data frames that display this information as a table.

In addition to the information as a table, it can also be displayed directly as plots with a simple call.


## Remap Gene Names

Besides protein IDs, gene names are also taken out of the respective Fasta files and mapped. These are needed for easier naming in plots and in analytical procedures such as enrichment analysis. Unfortunately, Fasta files are not always complete in terms of gene names. 

This method makes it possible to retrieve the assigned gene names based on the protein IDs with direct access to the Uniprot database and to fill the empty entries in the user file or even replace existing entries. There are multiple possible modes for which Names should be taken.

Modes:

* all - Use primarly fasta infos and additionally uniprot infos.
* fasta - Use information extracted from fasta headers.
* uniprot - Use mapping information from uniprot and use all gene names.
* uniprot_primary - Use mapping information from uniprot and only all primary gene names.
* uniprot_one - Use mapping information from uniprot and only use most frequent single gene name.


```{r}
# mandatory
data = data.table::fread("<file>")
mode = "<mode>" #  Mode of refilling. See above for more infos
protein_column = "Protein IDs" # Name of column with protein IDs

# optional 
organism = "human" # Specify organism the ids should match to
gene_column = "Gene names" # Name of column with gene names if exists
res_column = "Remapped Gene names" # Column name for remap genenames results. If None, the gene_column will be overridden.
skip_filled = TRUE # Bool to indicate if already filled gene names should be skipped
keep_empty = FALSE # Bool to indicate if empty remapped gene names cells should be kept or deleted
fasta = "<file>" # Fasta file when mode all or fasta
```

```{r}
remapped_data <- remap_genenames(data = data, mode = mode, protein_column = protein_column, 
                                 gene_column = gene_column, res_column = res_column,
                                 skip_filled = skip_filled, keep_empty = keep_empty,
                                 organism = organism, fasta = fasta)
```

### Log Information
Here, too, it is possible to subsequently obtain information on how many gene names were found for how many rows. 

This can also be displayed as a plot with a simple call.

## Reduce Gene Names

A well-known problem with gen symbols is that they are not unique and slight changes in spelling can lead to problems. Often there are different gene symbols for the same gene in UniProt. Depending on which protein IDs you used to get the gene symbol, you can get multiple gene symbols for the same gene by using the previous remap function.

This method makes it possible to reduce the gene symbols to a common gene symbol using different features and databases, thus preventing redundancy. There are multiple possible modes for which Names should be taken.

Modes:

* ensembl - Use gProfiler to reduce gene names to those having a Ensembl ID
* HGNC - Use HGNC database to reduce gene names to those having an entry in HGNC (only for human)
* mygeneinfo - Use mygeneinfo database to reduce gene names to those having an entry in mygeneinfo
* enrichment - Use gProfiler to reduce gene names to those having a functional annotation


```{r}
# mandatory
data = data.table::fread("<file>")
mode = "<mode>" #  Mode of refilling. See above for more infos
gene_column = "Gene names" # Name of column with gene names
organism = "human" # Specify organism the ids should match to

# optional 
gene_column = "Gene names" # Name of column with gene names if exists
res_column = "Reduced Gene names" # Column name for remap genenames results. If None, the gene_column will be overridden.
keep_empty = FALSE # Bool to indicate if empty remapped gene names cells should be kept or deleted
HGNC_mode = "mostfrequent" # Mode on how to select the gene names in HGNC (mostfrequent, all)
```

```{r}
reduced_data <- reduce_genenames(data = data, mode = mode, gene_column = gene_column, 
                                 organism = organism, keep_empty = keep_empty,
                                 res_column = res_column, HGNC_mode = HGNC_mode)
```

### Log Information
Here, too, it is possible to subsequently obtain information on how many gene names were reduced for how many rows. 

This can also be displayed as a plot with a simple call.

## Get Orthologs
Suppose you want to compare data between organisms, for example if you want to do a review across several species, you come across a known problem. Gene names differ between species, making it necessary to map all IDs to a selected organism through an ortholog mapping.

Using the commonly used gProfiler, this method simply maps the gene names from the current organism to the target organism. 

```{r}
# mandatory
data = data.table::fread("<file>")
source_organism = "rat" # Specify organism the ids should match to
target_organism = "human" # Specify organism the ids should match to
gene_column = "Gene names" # Name of column with gene names

# optional 
res_column = "Ortholog Gene names" # Set column name for ortholog results. If None, the gene_column will be overridden.
keep_empty = FALSE # Set True if empty rows should be kept
```

```{r}
ortholog_data <- get_orthologs(data = data, gene_column = gene_column, 
                               organism = source_organism, tar_organism = target_organism,
                               res_column = res_column, keep_empty = keep_empty)
```

### Log Information
Unfortunately, depending on the original and target organism, there are more or less cases where no orthologous gene could be found. For a simplified overview of how many cases this was the case, this method can be used to obtain this information.

As with the previous tasks, the log information can be displayed in plots.